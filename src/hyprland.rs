use anyhow::{Context, Result};
use serde::Deserialize;
use std::process::Command;
use std::thread;
use std::time::Duration;

use crate::profile::{LidSwitch, Monitor, Position, Profile, Workspace};

/// Get the Hyprland instance signature, with fallback discovery
/// Usually set in the environment, but we can discover it if needed
fn get_hyprland_instance_signature() -> Option<String> {
    // First check if it's already set
    if let Ok(sig) = std::env::var("HYPRLAND_INSTANCE_SIGNATURE") {
        return Some(sig);
    }

    // Try to discover from XDG_RUNTIME_DIR/hypr/
    let runtime_dir = std::env::var("XDG_RUNTIME_DIR").ok()?;
    let hypr_dir = std::path::Path::new(&runtime_dir).join("hypr");

    if let Ok(entries) = std::fs::read_dir(&hypr_dir) {
        for entry in entries.flatten() {
            let name = entry.file_name();
            let name_str = name.to_string_lossy();
            // Instance signatures look like: 386376400119dd46a767c9f8c8791fd22c7b6e61_1766260165_608814011
            if name_str.contains('_') && entry.path().is_dir() {
                return Some(name_str.to_string());
            }
        }
    }

    None
}

/// Create a hyprctl Command with the instance signature set
fn hyprctl_command() -> Command {
    let mut cmd = Command::new("hyprctl");
    if let Some(sig) = get_hyprland_instance_signature() {
        cmd.env("HYPRLAND_INSTANCE_SIGNATURE", sig);
    }
    cmd
}

// Timing constants for runtime apply
const MONITOR_APPLY_DELAY_MS: u64 = 1000;
const WORKSPACE_MOVE_RETRY_DELAY_MS: u64 = 500;
const WORKSPACE_MOVE_MAX_RETRIES: u8 = 3;

/// Raw monitor info from hyprctl monitors -j
#[derive(Debug, Deserialize)]
struct HyprMonitor {
    name: String,
    description: String,
    width: i32,
    height: i32,
    #[serde(rename = "refreshRate")]
    refresh_rate: f64,
    x: i32,
    y: i32,
    scale: f64,
    transform: u8,
}

/// Check if Hyprland is currently running
pub fn is_running() -> bool {
    Command::new("pgrep")
        .args(["-x", "Hyprland"])
        .output()
        .map(|o| o.status.success())
        .unwrap_or(false)
}

/// Detect currently connected monitors using hyprctl
pub fn detect_monitors() -> Result<Vec<Monitor>> {
    let output = hyprctl_command()
        .args(["monitors", "-j"])
        .output()
        .context("Failed to run hyprctl monitors")?;

    if !output.status.success() {
        anyhow::bail!("hyprctl monitors failed");
    }

    let hypr_monitors: Vec<HyprMonitor> = serde_json::from_slice(&output.stdout)
        .context("Failed to parse hyprctl output")?;

    let monitors = hypr_monitors
        .into_iter()
        .map(|m| {
            let resolution = format!("{}x{}", m.width, m.height);
            let mode = format!("{}x{}@{:.0}", m.width, m.height, m.refresh_rate);
            Monitor {
                name: m.name,
                description: Some(m.description),
                enabled: true,
                resolution,
                refresh_rate: m.refresh_rate,
                position: Position { x: m.x, y: m.y },
                scale: m.scale,
                transform: m.transform,
                mode,
            }
        })
        .collect();

    Ok(monitors)
}

/// Resolve stored monitor descriptions to current port names
/// This allows profiles to work even when dock assigns different port names
pub fn resolve_monitor_names(profile: &mut Profile) -> Result<()> {
    // Get current monitors from Hyprland
    let current_monitors = detect_monitors()?;

    for monitor in &mut profile.monitors {
        if let Some(ref desc) = monitor.description {
            // Find current monitor with matching description
            if let Some(current) = current_monitors.iter().find(|m| {
                m.description.as_ref() == Some(desc)
            }) {
                let old_name = std::mem::replace(&mut monitor.name, current.name.clone());

                // Update workspace references
                for ws in &mut profile.workspaces {
                    if ws.monitor == old_name {
                        ws.monitor = current.name.clone();
                    }
                }

                // Update lid_switch reference
                if let Some(ref mut lid) = profile.lid_switch {
                    if lid.monitor == old_name {
                        lid.monitor = current.name.clone();
                    }
                }
            }
        }
    }

    Ok(())
}

/// Generate Hyprland config content from a profile
pub fn generate_config(profile: &Profile) -> String {
    let mut lines = vec![format!(
        "# Generated by hyprpier from profile: {}",
        profile.name
    )];
    lines.push(format!(
        "# {}",
        profile.description.as_deref().unwrap_or("No description")
    ));
    lines.push(String::new());

    // Monitor lines
    for monitor in &profile.monitors {
        let line = if monitor.enabled {
            format!(
                "monitor = {},{},{}x{},{}",
                monitor.name, monitor.mode, monitor.position.x, monitor.position.y, monitor.scale
            )
        } else {
            format!("monitor = {},disable", monitor.name)
        };
        lines.push(line);
    }

    lines.push(String::new());

    // Workspace lines
    for ws in &profile.workspaces {
        let default_str = if ws.default { ",default:true" } else { "" };
        lines.push(format!(
            "workspace = {}, monitor:{}{}",
            ws.id, ws.monitor, default_str
        ));
    }

    // Lid switch bindings
    if let Some(ref lid) = profile.lid_switch {
        if lid.enabled {
            lines.push(String::new());
            lines.push("# Lid switch handling".to_string());
            lines.push(format!(
                "bindl = ,switch:on:Lid Switch,exec,hyprctl keyword monitor \"{},{}\"",
                lid.monitor, lid.on_close
            ));
            lines.push(format!(
                "bindl = ,switch:off:Lid Switch,exec,hyprctl keyword monitor \"{},{}\"",
                lid.monitor, lid.on_open
            ));
        }
    }

    lines.join("\n")
}

/// Write the config to ~/.config/hypr/monitors.conf
pub fn write_config(profile: &Profile) -> Result<()> {
    let config = generate_config(profile);
    let path = crate::config::hyprland_monitors_conf()?;

    // Ensure parent directory exists
    if let Some(parent) = path.parent() {
        std::fs::create_dir_all(parent)?;
    }

    std::fs::write(&path, config)
        .with_context(|| format!("Failed to write {}", path.display()))?;

    Ok(())
}

/// Apply a single monitor configuration via hyprctl
pub fn apply_monitor(monitor: &Monitor) -> Result<()> {
    let cmd = if monitor.enabled {
        format!(
            "{},{},{}x{},{}",
            monitor.name, monitor.mode, monitor.position.x, monitor.position.y, monitor.scale
        )
    } else {
        format!("{},disable", monitor.name)
    };

    let output = hyprctl_command()
        .args(["keyword", "monitor", &cmd])
        .output()
        .context("Failed to run hyprctl")?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        anyhow::bail!("hyprctl failed: {}", stderr);
    }

    Ok(())
}

/// Move a workspace to a monitor
pub fn move_workspace(workspace_id: u8, monitor: &str) -> Result<()> {
    let output = hyprctl_command()
        .args([
            "dispatch",
            "moveworkspacetomonitor",
            &format!("{} {}", workspace_id, monitor),
        ])
        .output()
        .context("Failed to move workspace")?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        anyhow::bail!("Failed to move workspace: {}", stderr);
    }

    Ok(())
}

/// Apply all monitors from a profile at runtime
pub fn apply_runtime(profile: &Profile) -> Result<()> {
    if !is_running() {
        return Ok(());
    }

    // Apply monitors
    for monitor in &profile.monitors {
        apply_monitor(monitor)?;
    }

    // Wait for monitor changes to take effect
    thread::sleep(Duration::from_millis(MONITOR_APPLY_DELAY_MS));

    // Move existing workspaces to correct monitors
    for ws in &profile.workspaces {
        for attempt in 0..WORKSPACE_MOVE_MAX_RETRIES {
            match move_workspace(ws.id, &ws.monitor) {
                Ok(_) => break,
                Err(_) if attempt < WORKSPACE_MOVE_MAX_RETRIES - 1 => {
                    thread::sleep(Duration::from_millis(WORKSPACE_MOVE_RETRY_DELAY_MS));
                }
                Err(e) => {
                    eprintln!("Warning: Failed to move workspace {}: {}", ws.id, e);
                }
            }
        }
    }

    Ok(())
}

/// Sort monitors: external first, laptop display (eDP) last
pub fn sort_monitors(monitors: &mut [Monitor]) {
    monitors.sort_by(|a, b| {
        let a_is_edp = a.name.to_lowercase().starts_with("edp");
        let b_is_edp = b.name.to_lowercase().starts_with("edp");
        a_is_edp.cmp(&b_is_edp)
    });
}

/// Auto-arrange monitors left-to-right
pub fn arrange_monitors(monitors: &mut [Monitor]) {
    let mut x_offset = 0;
    for monitor in monitors.iter_mut() {
        if monitor.enabled {
            monitor.position.x = x_offset;
            monitor.position.y = 0;
            // Parse width from resolution
            if let Some(width_str) = monitor.resolution.split('x').next() {
                if let Ok(width) = width_str.parse::<i32>() {
                    x_offset += width;
                }
            }
        }
    }
}

/// Generate default workspaces for monitors
pub fn generate_workspaces(monitors: &[Monitor]) -> Vec<Workspace> {
    let mut workspaces = Vec::new();
    let mut ws_id: u8 = 1;

    let enabled_monitors: Vec<_> = monitors.iter().filter(|m| m.enabled).collect();
    let count = enabled_monitors.len();

    for monitor in enabled_monitors.iter() {
        // Distribute workspaces: 5 each for multi-monitor, 10 for single monitor
        let ws_count = if count > 1 { 5 } else { 10 };

        for j in 0..ws_count {
            if ws_id > 10 {
                break;
            }
            workspaces.push(Workspace {
                id: ws_id,
                monitor: monitor.name.clone(),
                default: j == 0, // First workspace on each monitor is default
            });
            ws_id += 1;
        }
    }

    workspaces
}

/// Generate default lid switch config for laptop display
pub fn generate_lid_switch(monitors: &[Monitor]) -> Option<LidSwitch> {
    // Find laptop display (eDP)
    let edp = monitors
        .iter()
        .find(|m| m.name.to_lowercase().starts_with("edp"))?;

    Some(LidSwitch {
        enabled: true,
        monitor: edp.name.clone(),
        on_close: "disable".to_string(),
        on_open: format!("{},0x0,1", edp.mode),
    })
}
