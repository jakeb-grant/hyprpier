//! udev rules installation for auto-switching

use anyhow::{Context, Result};
use std::fs;
use std::path::Path;

const UDEV_RULES_PATH: &str = "/etc/udev/rules.d/99-hyprpier.rules";
const THUNDERBOLT_PATH: &str = "/sys/bus/thunderbolt/devices";

/// Generate the udev rules content
fn generate_rules() -> Result<String> {
    let exe_path = std::env::current_exe()
        .context("Failed to get hyprpier executable path")?;

    let exe = exe_path.to_string_lossy();

    Ok(format!(r#"# Hyprpier - Hyprland monitor profile auto-switching
# Generated by: hyprpier setup

# Auto-authorize all Thunderbolt devices
ACTION=="add", SUBSYSTEM=="thunderbolt", ATTR{{authorized}}=="0", ATTR{{authorized}}="1"

# Notify daemon of dock events
ACTION=="add", SUBSYSTEM=="thunderbolt", RUN+="{exe} notify"
ACTION=="remove", SUBSYSTEM=="thunderbolt", RUN+="{exe} notify"
"#))
}

/// Check if udev rules are installed
pub fn is_installed() -> bool {
    Path::new(UDEV_RULES_PATH).exists()
}

/// Install udev rules (called via sudo from TUI)
pub fn install() -> Result<()> {
    let rules = generate_rules()?;

    fs::write(UDEV_RULES_PATH, &rules)
        .with_context(|| format!("Failed to write {}", UDEV_RULES_PATH))?;

    println!("Installed udev rules to {}", UDEV_RULES_PATH);

    // Reload udev rules
    let _ = std::process::Command::new("udevadm")
        .args(["control", "--reload-rules"])
        .status();

    // Authorize any currently connected unauthorized devices
    authorize_connected_devices();

    println!("Auto-switching enabled!");

    Ok(())
}

/// Authorize all currently connected Thunderbolt devices
fn authorize_connected_devices() {
    let tb_path = Path::new(THUNDERBOLT_PATH);
    if !tb_path.exists() {
        return;
    }

    let entries = match fs::read_dir(tb_path) {
        Ok(e) => e,
        Err(_) => return,
    };

    for entry in entries.flatten() {
        let name = entry.file_name();
        let name_str = name.to_string_lossy();

        // Only process device entries (e.g., "0-1"), skip host controllers ("X-0") and domains
        if !name_str.contains('-') || name_str.ends_with("-0") {
            continue;
        }

        let device_path = entry.path();
        let auth_path = device_path.join("authorized");

        // Check if unauthorized
        if let Ok(status) = fs::read_to_string(&auth_path) {
            if status.trim() == "0" {
                // Authorize the device
                if fs::write(&auth_path, "1").is_ok() {
                    let device_name = fs::read_to_string(device_path.join("device_name"))
                        .map(|s| s.trim().to_string())
                        .unwrap_or_else(|_| name_str.to_string());
                    println!("Authorized: {}", device_name);
                }
            }
        }
    }
}

/// Uninstall udev rules (called via sudo from TUI)
pub fn uninstall() -> Result<()> {
    let path = Path::new(UDEV_RULES_PATH);

    if !path.exists() {
        println!("No udev rules installed");
        return Ok(());
    }

    fs::remove_file(path)
        .with_context(|| format!("Failed to remove {}", UDEV_RULES_PATH))?;

    println!("Removed udev rules");

    // Reload udev rules
    let _ = std::process::Command::new("udevadm")
        .args(["control", "--reload-rules"])
        .status();

    println!("Auto-switching disabled");

    Ok(())
}
