//! udev rules and systemd service installation for auto-switching

use anyhow::{bail, Context, Result};
use std::fs;
use std::path::Path;

use crate::thunderbolt;

const UDEV_RULES_PATH: &str = "/etc/udev/rules.d/99-hyprpier.rules";
const SYSTEMD_SERVICE_PATH: &str = "/etc/systemd/system/hyprpier-resume.service";
const THUNDERBOLT_PATH: &str = "/sys/bus/thunderbolt/devices";

/// Generate the udev rules content
fn generate_rules() -> Result<String> {
    let exe_path = std::env::current_exe()
        .context("Failed to get hyprpier executable path")?;

    let exe = exe_path.to_string_lossy();

    Ok(format!(r#"# Hyprpier - Hyprland monitor profile auto-switching
# Generated by: hyprpier setup

# Auto-authorize all Thunderbolt devices
ACTION=="add", SUBSYSTEM=="thunderbolt", ATTR{{authorized}}=="0", ATTR{{authorized}}="1"

# Force Thunderbolt controller power on if supported (prevents D3hot sleep issues)
ACTION=="add|change", SUBSYSTEM=="thunderbolt", RUN+="/bin/sh -c 'echo 1 > /sys/bus/wmi/devices/86CCFD48-205E-4A77-9C48-2021CBEDE341/force_power 2>/dev/null || true'"

# Force PCI rescan to recover devices after resume from sleep
ACTION=="add|change", SUBSYSTEM=="thunderbolt", RUN+="/bin/sh -c 'echo 1 > /sys/bus/pci/rescan'"

# Notify daemon of dock events
ACTION=="add", SUBSYSTEM=="thunderbolt", RUN+="{exe} notify"
ACTION=="remove", SUBSYSTEM=="thunderbolt", RUN+="{exe} notify"
"#))
}

/// Check if udev rules are installed
pub fn is_installed() -> bool {
    Path::new(UDEV_RULES_PATH).exists()
}

/// Install udev rules (called via sudo from TUI)
pub fn install() -> Result<()> {
    let rules = generate_rules()?;

    fs::write(UDEV_RULES_PATH, &rules)
        .with_context(|| format!("Failed to write {}", UDEV_RULES_PATH))?;

    println!("Installed udev rules to {}", UDEV_RULES_PATH);

    // Reload udev rules
    let _ = std::process::Command::new("udevadm")
        .args(["control", "--reload-rules"])
        .status();

    // Authorize any currently connected unauthorized devices
    authorize_connected_devices();

    println!("Auto-switching enabled!");

    Ok(())
}

/// Authorize all currently connected Thunderbolt devices
fn authorize_connected_devices() {
    let tb_path = Path::new(THUNDERBOLT_PATH);
    if !tb_path.exists() {
        return;
    }

    let entries = match fs::read_dir(tb_path) {
        Ok(e) => e,
        Err(_) => return,
    };

    for entry in entries.flatten() {
        let name = entry.file_name();
        let name_str = name.to_string_lossy();

        // Only process device entries (e.g., "0-1"), skip host controllers ("X-0") and domains
        if !name_str.contains('-') || name_str.ends_with("-0") {
            continue;
        }

        let device_path = entry.path();
        let auth_path = device_path.join("authorized");

        // Check if unauthorized
        if let Ok(status) = fs::read_to_string(&auth_path) {
            if status.trim() == "0" {
                // Authorize the device
                if fs::write(&auth_path, "1").is_ok() {
                    let device_name = fs::read_to_string(device_path.join("device_name"))
                        .map(|s| s.trim().to_string())
                        .unwrap_or_else(|_| name_str.to_string());
                    println!("Authorized: {}", device_name);
                }
            }
        }
    }
}

/// Uninstall udev rules (called via sudo from TUI)
pub fn uninstall() -> Result<()> {
    let path = Path::new(UDEV_RULES_PATH);

    if !path.exists() {
        println!("No udev rules installed");
        return Ok(());
    }

    fs::remove_file(path)
        .with_context(|| format!("Failed to remove {}", UDEV_RULES_PATH))?;

    println!("Removed udev rules");

    // Reload udev rules
    let _ = std::process::Command::new("udevadm")
        .args(["control", "--reload-rules"])
        .status();

    println!("Auto-switching disabled");

    Ok(())
}

/// Check if resume service is installed
pub fn is_resume_service_installed() -> bool {
    Path::new(SYSTEMD_SERVICE_PATH).exists()
}

/// Generate the systemd resume service content
fn generate_resume_service(pci_address: &str) -> String {
    format!(
        r#"# Hyprpier - Reset Thunderbolt controller on resume
# Generated by: hyprpier setup --resume

[Unit]
Description=Reset Thunderbolt controller on resume
After=suspend.target hibernate.target hybrid-sleep.target suspend-then-hibernate.target

[Service]
Type=oneshot
ExecStart=/bin/sh -c 'echo 1 > /sys/bus/pci/devices/{pci}/remove; sleep 1; echo 1 > /sys/bus/pci/rescan'

[Install]
WantedBy=suspend.target hibernate.target hybrid-sleep.target suspend-then-hibernate.target
"#,
        pci = pci_address
    )
}

/// Install systemd resume service (called via sudo from TUI)
pub fn install_resume_service() -> Result<()> {
    // Detect Thunderbolt controller PCI address
    let pci_address = thunderbolt::get_controller_pci_address()
        .context("No Thunderbolt controller found. Is your system Thunderbolt-capable?")?;

    println!("Detected Thunderbolt controller at: {}", pci_address);

    let service = generate_resume_service(&pci_address);

    fs::write(SYSTEMD_SERVICE_PATH, &service)
        .with_context(|| format!("Failed to write {}", SYSTEMD_SERVICE_PATH))?;

    println!("Installed systemd service to {}", SYSTEMD_SERVICE_PATH);

    // Enable the service
    match std::process::Command::new("systemctl")
        .args(["enable", "hyprpier-resume.service"])
        .status()
    {
        Ok(status) if status.success() => {
            println!("Enabled hyprpier-resume.service");
        }
        _ => {
            bail!("Failed to enable hyprpier-resume.service");
        }
    }

    println!("Resume fix enabled! Thunderbolt controller will reset on wake from sleep.");

    Ok(())
}

/// Uninstall systemd resume service (called via sudo from TUI)
pub fn uninstall_resume_service() -> Result<()> {
    let path = Path::new(SYSTEMD_SERVICE_PATH);

    if !path.exists() {
        println!("No resume service installed");
        return Ok(());
    }

    // Disable the service first
    let _ = std::process::Command::new("systemctl")
        .args(["disable", "hyprpier-resume.service"])
        .status();

    fs::remove_file(path)
        .with_context(|| format!("Failed to remove {}", SYSTEMD_SERVICE_PATH))?;

    println!("Removed resume service");

    // Reload systemd
    let _ = std::process::Command::new("systemctl")
        .args(["daemon-reload"])
        .status();

    println!("Resume fix disabled");

    Ok(())
}
